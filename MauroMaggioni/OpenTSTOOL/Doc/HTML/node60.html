<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>6.20.3 Member functions</TITLE>
<META NAME="description" CONTENT="6.20.3 Member functions">
<META NAME="keywords" CONTENT="manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="manual.css">

<LINK REL="previous" HREF="node59.html">
<LINK REL="up" HREF="node57.html">
<LINK REL="next" HREF="node61.html">
</HEAD>

<BODY bgcolor="#FFFFFF" text="#000000">
<!--Navigation Panel--><font face="arial, helvetica">
<TABLE WIDTH=100%><TR><TD ALIGN=LEFT><font face="arial, helvetica">  <A HREF=http://www.physik3.gwdg.de/tstool/index.html>TSTOOL home page</A>  | TSTOOL documentation page | <A HREF=http://www.physik3.gwdg.de/tstool/link.html>TSTOOL link page</A> <BR></TABLE><HR>
<A NAME="tex2html1256"
  HREF="node61.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.gif"></A> 
<A NAME="tex2html1252"
  HREF="node57.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.gif"></A> 
<A NAME="tex2html1248"
  HREF="node59.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.gif"></A> 
<A NAME="tex2html1254"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1257"
  HREF="node61.html">6.21 Class description</A>
<B> Up:</B> <A NAME="tex2html1253"
  HREF="node57.html">6.20 Class signal</A>
<B> Previous:</B> <A NAME="tex2html1249"
  HREF="node59.html">6.20.2 Attributes</A>
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html1258"
  HREF="node60.html#SECTION007203100000000000000">6.20.3.1 abs</A>
<LI><A NAME="tex2html1259"
  HREF="node60.html#SECTION007203200000000000000">6.20.3.2 acf</A>
<LI><A NAME="tex2html1260"
  HREF="node60.html#SECTION007203300000000000000">6.20.3.3 acp</A>
<LI><A NAME="tex2html1261"
  HREF="node60.html#SECTION007203400000000000000">6.20.3.4 amutual</A>
<LI><A NAME="tex2html1262"
  HREF="node60.html#SECTION007203500000000000000">6.20.3.5 amutual2</A>
<LI><A NAME="tex2html1263"
  HREF="node60.html#SECTION007203600000000000000">6.20.3.6 analyze</A>
<LI><A NAME="tex2html1264"
  HREF="node60.html#SECTION007203700000000000000">6.20.3.7 arch</A>
<LI><A NAME="tex2html1265"
  HREF="node60.html#SECTION007203800000000000000">6.20.3.8 boxdim</A>
<LI><A NAME="tex2html1266"
  HREF="node60.html#SECTION007203900000000000000">6.20.3.9 cao</A>
<LI><A NAME="tex2html1267"
  HREF="node60.html#SECTION0072031000000000000000">6.20.3.10 center</A>
<LI><A NAME="tex2html1268"
  HREF="node60.html#SECTION0072031100000000000000">6.20.3.11 corrdim</A>
<LI><A NAME="tex2html1269"
  HREF="node60.html#SECTION0072031200000000000000">6.20.3.12 corrsum</A>
<LI><A NAME="tex2html1270"
  HREF="node60.html#SECTION0072031300000000000000">6.20.3.13 corrsum2</A>
<LI><A NAME="tex2html1271"
  HREF="node60.html#SECTION0072031400000000000000">6.20.3.14 crosscorrdim</A>
<LI><A NAME="tex2html1272"
  HREF="node60.html#SECTION0072031500000000000000">6.20.3.15 cut</A>
<LI><A NAME="tex2html1273"
  HREF="node60.html#SECTION0072031600000000000000">6.20.3.16 db</A>
<LI><A NAME="tex2html1274"
  HREF="node60.html#SECTION0072031700000000000000">6.20.3.17 delaytime</A>
<LI><A NAME="tex2html1275"
  HREF="node60.html#SECTION0072031800000000000000">6.20.3.18 diff</A>
<LI><A NAME="tex2html1276"
  HREF="node60.html#SECTION0072031900000000000000">6.20.3.19 dimensions</A>
<LI><A NAME="tex2html1277"
  HREF="node60.html#SECTION0072032000000000000000">6.20.3.20 display</A>
<LI><A NAME="tex2html1278"
  HREF="node60.html#SECTION0072032100000000000000">6.20.3.21 embed</A>
<LI><A NAME="tex2html1279"
  HREF="node60.html#SECTION0072032200000000000000">6.20.3.22 fft</A>
<LI><A NAME="tex2html1280"
  HREF="node60.html#SECTION0072032300000000000000">6.20.3.23 filterbank</A>
<LI><A NAME="tex2html1281"
  HREF="node60.html#SECTION0072032400000000000000">6.20.3.24 firstmax</A>
<LI><A NAME="tex2html1282"
  HREF="node60.html#SECTION0072032500000000000000">6.20.3.25 firstmin</A>
<LI><A NAME="tex2html1283"
  HREF="node60.html#SECTION0072032600000000000000">6.20.3.26 firstzero</A>
<LI><A NAME="tex2html1284"
  HREF="node60.html#SECTION0072032700000000000000">6.20.3.27 fracdims</A>
<LI><A NAME="tex2html1285"
  HREF="node60.html#SECTION0072032800000000000000">6.20.3.28 getaxis</A>
<LI><A NAME="tex2html1286"
  HREF="node60.html#SECTION0072032900000000000000">6.20.3.29 gmi</A>
<LI><A NAME="tex2html1287"
  HREF="node60.html#SECTION0072033000000000000000">6.20.3.30 histo</A>
<LI><A NAME="tex2html1288"
  HREF="node60.html#SECTION0072033100000000000000">6.20.3.31 infodim</A>
<LI><A NAME="tex2html1289"
  HREF="node60.html#SECTION0072033200000000000000">6.20.3.32 infodim2</A>
<LI><A NAME="tex2html1290"
  HREF="node60.html#SECTION0072033300000000000000">6.20.3.33 int</A>
<LI><A NAME="tex2html1291"
  HREF="node60.html#SECTION0072033400000000000000">6.20.3.34 intspikeint</A>
<LI><A NAME="tex2html1292"
  HREF="node60.html#SECTION0072033500000000000000">6.20.3.35 intspikint</A>
<LI><A NAME="tex2html1293"
  HREF="node60.html#SECTION0072033600000000000000">6.20.3.36 largelyap</A>
<LI><A NAME="tex2html1294"
  HREF="node60.html#SECTION0072033700000000000000">6.20.3.37 level_adaption</A>
<LI><A NAME="tex2html1295"
  HREF="node60.html#SECTION0072033800000000000000">6.20.3.38 localdensity</A>
<LI><A NAME="tex2html1296"
  HREF="node60.html#SECTION0072033900000000000000">6.20.3.39 max</A>
<LI><A NAME="tex2html1297"
  HREF="node60.html#SECTION0072034000000000000000">6.20.3.40 medianfilt</A>
<LI><A NAME="tex2html1298"
  HREF="node60.html#SECTION0072034100000000000000">6.20.3.41 merge</A>
<LI><A NAME="tex2html1299"
  HREF="node60.html#SECTION0072034200000000000000">6.20.3.42 min</A>
<LI><A NAME="tex2html1300"
  HREF="node60.html#SECTION0072034300000000000000">6.20.3.43 minus</A>
<LI><A NAME="tex2html1301"
  HREF="node60.html#SECTION0072034400000000000000">6.20.3.44 movav</A>
<LI><A NAME="tex2html1302"
  HREF="node60.html#SECTION0072034500000000000000">6.20.3.45 multires</A>
<LI><A NAME="tex2html1303"
  HREF="node60.html#SECTION0072034600000000000000">6.20.3.46 nearneigh</A>
<LI><A NAME="tex2html1304"
  HREF="node60.html#SECTION0072034700000000000000">6.20.3.47 norm1</A>
<LI><A NAME="tex2html1305"
  HREF="node60.html#SECTION0072034800000000000000">6.20.3.48 norm2</A>
<LI><A NAME="tex2html1306"
  HREF="node60.html#SECTION0072034900000000000000">6.20.3.49 pca</A>
<LI><A NAME="tex2html1307"
  HREF="node60.html#SECTION0072035000000000000000">6.20.3.50 plosivity</A>
<LI><A NAME="tex2html1308"
  HREF="node60.html#SECTION0072035100000000000000">6.20.3.51 plus</A>
<LI><A NAME="tex2html1309"
  HREF="node60.html#SECTION0072035200000000000000">6.20.3.52 poincare</A>
<LI><A NAME="tex2html1310"
  HREF="node60.html#SECTION0072035300000000000000">6.20.3.53 power</A>
<LI><A NAME="tex2html1311"
  HREF="node60.html#SECTION0072035400000000000000">6.20.3.54 predict</A>
<LI><A NAME="tex2html1312"
  HREF="node60.html#SECTION0072035500000000000000">6.20.3.55 predict2</A>
<LI><A NAME="tex2html1313"
  HREF="node60.html#SECTION0072035600000000000000">6.20.3.56 rang</A>
<LI><A NAME="tex2html1314"
  HREF="node60.html#SECTION0072035700000000000000">6.20.3.57 removeaxis</A>
<LI><A NAME="tex2html1315"
  HREF="node60.html#SECTION0072035800000000000000">6.20.3.58 return_time</A>
<LI><A NAME="tex2html1316"
  HREF="node60.html#SECTION0072035900000000000000">6.20.3.59 reverse</A>
<LI><A NAME="tex2html1317"
  HREF="node60.html#SECTION0072036000000000000000">6.20.3.60 rms</A>
<LI><A NAME="tex2html1318"
  HREF="node60.html#SECTION0072036100000000000000">6.20.3.61 scale</A>
<LI><A NAME="tex2html1319"
  HREF="node60.html#SECTION0072036200000000000000">6.20.3.62 scalogram</A>
<LI><A NAME="tex2html1320"
  HREF="node60.html#SECTION0072036300000000000000">6.20.3.63 setaxis</A>
<LI><A NAME="tex2html1321"
  HREF="node60.html#SECTION0072036400000000000000">6.20.3.64 setunit</A>
<LI><A NAME="tex2html1322"
  HREF="node60.html#SECTION0072036500000000000000">6.20.3.65 shift</A>
<LI><A NAME="tex2html1323"
  HREF="node60.html#SECTION0072036600000000000000">6.20.3.66 signal</A>
<LI><A NAME="tex2html1324"
  HREF="node60.html#SECTION0072036700000000000000">6.20.3.67 spacing</A>
<LI><A NAME="tex2html1325"
  HREF="node60.html#SECTION0072036800000000000000">6.20.3.68 spec</A>
<LI><A NAME="tex2html1326"
  HREF="node60.html#SECTION0072036900000000000000">6.20.3.69 spec2</A>
<LI><A NAME="tex2html1327"
  HREF="node60.html#SECTION0072037000000000000000">6.20.3.70 stts</A>
<LI><A NAME="tex2html1328"
  HREF="node60.html#SECTION0072037100000000000000">6.20.3.71 sttserror</A>
<LI><A NAME="tex2html1329"
  HREF="node60.html#SECTION0072037200000000000000">6.20.3.72 surrogate1</A>
<LI><A NAME="tex2html1330"
  HREF="node60.html#SECTION0072037300000000000000">6.20.3.73 surrogate2</A>
<LI><A NAME="tex2html1331"
  HREF="node60.html#SECTION0072037400000000000000">6.20.3.74 surrogate3</A>
<LI><A NAME="tex2html1332"
  HREF="node60.html#SECTION0072037500000000000000">6.20.3.75 surrogate_test</A>
<LI><A NAME="tex2html1333"
  HREF="node60.html#SECTION0072037600000000000000">6.20.3.76 swap</A>
<LI><A NAME="tex2html1334"
  HREF="node60.html#SECTION0072037700000000000000">6.20.3.77 takens_estimator</A>
<LI><A NAME="tex2html1335"
  HREF="node60.html#SECTION0072037800000000000000">6.20.3.78 tc3</A>
<LI><A NAME="tex2html1336"
  HREF="node60.html#SECTION0072037900000000000000">6.20.3.79 trend</A>
<LI><A NAME="tex2html1337"
  HREF="node60.html#SECTION0072038000000000000000">6.20.3.80 trev</A>
<LI><A NAME="tex2html1338"
  HREF="node60.html#SECTION0072038100000000000000">6.20.3.81 upsample</A>
<LI><A NAME="tex2html1339"
  HREF="node60.html#SECTION0072038200000000000000">6.20.3.82 view</A>
<LI><A NAME="tex2html1340"
  HREF="node60.html#SECTION0072038300000000000000">6.20.3.83 write</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H2><A NAME="SECTION007203000000000000000">
6.20.3 Member functions</A>
</H2>

<P>
<A NAME="f26:FUNCTIONS"></A>

<H3><A NAME="SECTION007203100000000000000">
6.20.3.1 abs</A>
</H3>

<P>
<A NAME="f29"></A><B>Syntax:</B>

<UL>
<LI><TT>abs(s)</TT>
</LI>
</UL>

<P>
Take absolut value of all data values of signal <TT>s</TT>. If sample
values are  complex, <TT>abs(s)</TT> returns the complex modulus (magnitude) of each sample.

<P>

<H3><A NAME="SECTION007203200000000000000"></A>
<A NAME="f30"></A>
<BR>
6.20.3.2 acf
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>acf(s, len)</TT>
</LI>
</UL>

<P>
<B>Input arguments:</B>

<UL>
<LI><TT>len</TT> -length of the fft  <EM>(optional)</EM>
</LI>
</UL>

<P>
Autocorrelation function for real scalar signals, using fft (of length <TT>len</TT>). If <TT>len</TT> is ommited a default value is calculated. The maximum
of the calculated length is 128.

<H3><A NAME="SECTION007203300000000000000">
6.20.3.3 acp</A>
</H3>

<P>
<A NAME="f31"></A><B>Syntax:</B>

<UL>
<LI><TT>acp(s, tau, past, maxdelay, maxdim, nref)</TT>
</LI>
</UL>

<P>
<B>Input arguments:</B>

<UL>
<LI><TT>tau</TT> - proper delay time for <TT>s</TT>
</LI>
<LI><TT>past</TT> - number of samples to exclude before and after 
       reference index (to avoid correlation effects) 
</LI>
<LI><TT>maxdelay</TT> - maximal delay (should be much smaller than the lenght of
<TT>s</TT>)  <EM>(optional)</EM>
</LI>
<LI><TT>maxdim</TT> - maximal dimension to use  <EM>(optional)</EM>
</LI>
<LI><TT>nref</TT> - number of reference points  <EM>(optional)</EM>
</LI>
</UL>
Auto crossprediction function for real scalar signals for increasing
dimension. The default value for <TT>maxdelay</TT> is 25% of the input signal's
length. The default for <TT>maxdim</TT> is 8 and for <TT>nref</TT> it is 10% of the
input signal's length.

<H3><A NAME="SECTION007203400000000000000">
6.20.3.4 amutual</A>
</H3>

<P>
<A NAME="f32"></A><B>Syntax:</B>

<UL>
<LI><TT>amutual(s, maxtau, bins)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>maxtau</TT> - maximal delay (should be much smaller than the lenght of
<TT>s</TT>)  <EM>(optional)</EM>
</LI>
<LI><TT>bins</TT> - number of bins used for histogram calculation 
<EM>(optional)</EM>
</LI>
</UL>
Auto mutual information function for real scalar signals, can be used to
determine a proper delay time for time-delay reconstruction. The default value
for <TT>maxtau</TT> is 25% of the input signal's length. The default number of
bins is 128.
<P><!-- MATH
 \begin{displaymath}
I=\sum P(A,B)\log_2\frac{P(A,B)}{P(A)P(B)}
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="227" HEIGHT="55" ALIGN="MIDDLE" BORDER="0"
 SRC="img29.gif"
 ALT="$\displaystyle I=\sum P(A,B)\log_2\frac{P(A,B)}{P(A)P(B)}
$">
</DIV><P>
</P>
<H3><A NAME="SECTION007203500000000000000">
6.20.3.5 amutual2</A>
</H3>

<P>
<A NAME="f33"></A><B>Syntax:</B>

<UL>
<LI><TT>amutual2(s, len)</TT>
</LI>
</UL>

<P>
<B>Input arguments:</B>

<UL>
<LI><TT>len</TT> - maximal lag
</LI>
</UL>

<P>
Auto mutual information (average) function for real scalar signals using 128
equidistant partitions.

<H3><A NAME="SECTION007203600000000000000">
6.20.3.6 analyze</A>
</H3>

<P>
<A NAME="f34"></A><B>Syntax:</B>

<UL>
<LI><TT>analyze(s, maxdim)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>maxdim</TT> - analyze will not use a dimension higher than this limit
</LI>
</UL>

<P>
Try to do a automatic analysis procedure of a time series. The time series is
embedded using the first zero of the auto mutual information function for the
delay time.

<H3><A NAME="SECTION007203700000000000000">
6.20.3.7 arch</A>
</H3>

<P>
<A NAME="f36"></A><B>Syntax:</B>

<UL>
<LI><TT>[rs, archetypes]=arch(s, na, mode='normalized')</TT>
</LI>
</UL>

<P>
<B>Input arguments:</B>

<UL>
<LI><TT>na</TT> - number of generated archetypes 
</LI>
<LI><TT>mode</TT> - mode can be one of the following : '<TT>normalized</TT>'
, '<TT>mean</TT>', '<TT>raw</TT>'  <EM>(optional)</EM>
</LI>
</UL>
Archetypal analysis of column orientated data set:

<UL>
<LI>each row of data is one 'observation', e.g. the sample values of
     all channels in a multichannel measurement at one point in time
</LI>
<LI>in mode '<TT>normalized</TT>' each column of data is centered by removing its mean
       and then normalized by dividing through its standard deviation before
       the covariance matrix is calculated
</LI>
<LI>in mode '<TT>mean</TT>' only the mean of every column of data is removed
</LI>
<LI>in mode '<TT>raw</TT>' no preprocessing is applied to data
</LI>
</UL>
Default value for <TT>mode</TT> is '<TT>normalized</TT>'.

<H3><A NAME="SECTION007203800000000000000">
6.20.3.8 boxdim</A>
</H3>

<P>
<A NAME="f37"></A><B>Syntax:</B>

<UL>
<LI><TT>rs = boxdim(s, bins)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>s</TT> - data points (row vectors)
</LI>
<LI><TT>bins</TT> - maximal number of partition per axis  <EM>(optional)</EM>
</LI>
</UL>

<P>
Compute the boxcounting (capacity) dimension of a time-delay reconstructed
timeseries <TT>s</TT> for dimensions from 1 to <TT>D</TT>, where <TT>D</TT> is the
dimension of the input vectors using boxcounting approach. The default number
of bins is 100.

<H3><A NAME="SECTION007203900000000000000"></A>
<A NAME="f38"></A>
<BR>
6.20.3.9 cao
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>[E1, E2] = cao(s, maxdim, tau, NNR, Nref)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>s</TT> - scalar input signal
</LI>
<LI><TT>maxdim</TT> - maximal dimension
</LI>
<LI><TT>tau</TT> - delay time
</LI>
<LI><TT>NNR</TT> - number of nearest neighbor to use
</LI>
<LI><TT>Nref</TT> - number of reference points (-1 means: use all points)
</LI>
</UL>

<P>
Estimate minimum embedding dimension using Cao's method.

<P>
The second output argument, <TT>E2</TT>, can be used to distinguish between
deterministic and random data.

<H3><A NAME="SECTION0072031000000000000000">
6.20.3.10 center</A>
</H3>

<P>
<A NAME="f40"></A><B>Syntax:</B>

<UL>
<LI><TT>center(s)</TT>
</LI>
</UL>

<P>
Center signal by removing it's mean.

<H3><A NAME="SECTION0072031100000000000000"></A>
<A NAME="f41"></A>
<BR>
6.20.3.11 corrdim
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = corrdim(s, bins)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>s</TT> - data points (row vectors)
</LI>
<LI><TT>bins</TT> - maximal number of partition per axis  <EM>(optional)</EM>
</LI>
</UL>

<P>
Compute the correlation dimension of a time-delay reconstructed timeseries s
for dimensions from 1 to <TT>D</TT>, where <TT>D</TT> is the dimension of the input vectors
using boxcounting approach. The default number of <TT>bins</TT> is 100.

<H3><A NAME="SECTION0072031200000000000000"></A>
<A NAME="f41a"></A>
<BR>
6.20.3.12 corrsum
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = corrsum(s, n, range, past, bins)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>n</TT> - number of randomly chosen reference points (<TT>n</TT> == -1 means: use all points)
</LI>
<LI><TT>range</TT> - maximal relative search radius (relative to attractor size) 0..1
</LI>
<LI><TT>past</TT> - number of samples to exclude before and after each reference index
</LI>
<LI><TT>bins</TT> - number of bins  <EM>(optional)</EM>
</LI>
</UL>
Compute scaling of correlation sum for time-delay reconstructed timeseries <TT>s</TT>
(Grassberger-Proccacia Algorithm), using fast nearest neighbor search. Default
number of <TT>bins</TT> is 20.

<H3><A NAME="SECTION0072031300000000000000"></A>
<A NAME="f42"></A>
<BR>
6.20.3.13 corrsum2
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = corrsum2(s, npairs, range, past, bins)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>npairs</TT> - number of pairs per bins
</LI>
<LI><TT>range</TT> - maximal relative search radius (relative to attractor size) 0..1
</LI>
<LI><TT>past</TT> - number of samples to exclude before and after each reference index
</LI>
<LI><TT>bins</TT> - number of bins (optional), defaults to 32
</LI>
</UL>
Compute scaling of correlation sum for time-delay reconstructed timeseries <TT>s</TT>
(Grassberger-Proccacia Algorithm), using fast nearest neighbor search.

<H3><A NAME="SECTION0072031400000000000000"></A>
<A NAME="f43"></A>
<BR>
6.20.3.14 crosscorrdim
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = crosscorrdim(s, s2, n, range, past, bins)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>n</TT> - number of randomly chosen reference points (n == -1 means : use all points)
</LI>
<LI><TT>range</TT> - maximal relative search radius (relative to size of data set s2) 0..1
</LI>
<LI><TT>past</TT> - number of samples to exclude before and after each reference index
</LI>
<LI><TT>bins</TT> - number of bins  <EM>(optional)</EM>
</LI>
</UL>
Compute scaling of cross-correlation sum for time-delay reconstructed timeseries <TT>s</TT> against
signal s2 (with same dimension as s), using fast nearest neighbor search.
Reference points are taken out of signal <TT>s</TT>, while neigbors are searched in
<TT>s2</TT>. The default number of <TT>bins</TT> is 32.

<H3><A NAME="SECTION0072031500000000000000"></A>
<A NAME="f44"></A>
<BR>
6.20.3.15 cut
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = cut(s, dim, start, stop)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>dim</TT> - dimension along which the signal is cutted
</LI>
<LI><TT>start</TT> - position where to start the cut
</LI>
<LI><TT>stop</TT> - position where to stop  <EM>(optional)</EM>
</LI>
</UL>
Cut a part of the signal. If <TT>stop</TT> is ommited only the data at <TT>start</TT>
is cutted.

<H3><A NAME="SECTION0072031600000000000000"></A>
<A NAME="f45"></A>
<BR>
6.20.3.16 db
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>db(s, dbmin)</TT>
</LI>
</UL>
Compute decibel values of signal relative to a reference value that is
determined by the signal's <TT>yunit</TT> values below <TT>dbmin</TT> are
set to <TT>dbmin</TT>. If <TT>dbmin</TT> is ommited it is set to -120.

<H3><A NAME="SECTION0072031700000000000000"></A>
<A NAME="f46"></A>
<BR>
6.20.3.17 delaytime
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>tau = delaytime(s, maxdelay, past)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>maxdelay</TT> - maximal delay time
</LI>
<LI><TT>past</TT> - ?
</LI>
</UL>
Compute optimal delaytime for a scalar timeseries with method of Parlitz and Wichard.

<H3><A NAME="SECTION0072031800000000000000"></A>
<A NAME="f47"></A>
<BR>
6.20.3.18 diff
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>diff(s, nth)</TT>
</LI>
</UL>
Compute the <TT>n</TT>th numerical derivative along dimension 1. <TT>s</TT> has be to sampled equidistantly.

<H3><A NAME="SECTION0072031900000000000000"></A>
<A NAME="f48"></A>
<BR>
6.20.3.19 dimensions
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>[bc,in,co] = dimensions(s, bins)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>s</TT> - data points (row vectors)
</LI>
<LI><TT>bins</TT> - maximal number of partition per axis, default is 100
</LI>
</UL>
<B>Output arguments:</B>

<UL>
<LI><TT>bc</TT> - scaling of boxes with partititon sizes <!-- MATH
 $(\log_2-\log_2)$
 -->
<IMG
 WIDTH="90" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.gif"
 ALT="$ (\log_2-\log_2)$">

</LI>
<LI><TT>in</TT> - scaling of information with partititon sizes <!-- MATH
 $(\log_2-\log_2)$
 -->
<IMG
 WIDTH="90" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.gif"
 ALT="$ (\log_2-\log_2)$">

</LI>
<LI><TT>co</TT> - scaling of correlation with partititon sizes <!-- MATH
 $(\log_2-\log_2)$
 -->
<IMG
 WIDTH="90" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.gif"
 ALT="$ (\log_2-\log_2)$">

</LI>
</UL>
Compute boxcounting, information and correlation dimension of a time-delay 
reconstructed timeseries <TT>s</TT> for dimensions from 1 to <TT>D</TT>,
where <TT>D</TT> is the dimension of the input vectors using boxcounting approach.

<P>
Scale data to be within 0 and 1. Give a sortiment of (integer)
partitionsizes with almost exponential behaviour.

<H3><A NAME="SECTION0072032000000000000000"></A>
<A NAME="f49"></A>
<BR>
6.20.3.20 display
</H3>

<H3><A NAME="SECTION0072032100000000000000"></A>
<A NAME="f50"></A>
<BR>
6.20.3.21 embed
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>emb = embed(s, dim, delay, shift, windowtype)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>dim</TT> - embedding dimension
</LI>
<LI><TT>delay</TT> - time delay  <EM>(optional)</EM>
</LI>
<LI><TT>shift</TT> - shift for two sequent time delay vectors  <EM>(optional)</EM>
</LI>
<LI><TT>windowtype</TT> - type of window  <EM>(optional)</EM>
</LI>
</UL>
<B>Output arguments:</B>

<UL>
<LI><TT>emb</TT> - n by <TT>dim</TT> array, each row contains the coordinates of
one point
</LI>
</UL>
Embeds signal <TT>s</TT> with embedding dimension <TT>dim</TT> and delay
<TT>delay</TT> (in samples). <TT>s</TT> must be a scalar time series. The default
values for <TT>dim</TT> and <TT>delay</TT> are equal to one. The default value for
<TT>windowtype</TT> is 'Rect', which is currently the only possible value.

<H3><A NAME="SECTION0072032200000000000000"></A>
<A NAME="f51"></A>
<BR>
6.20.3.22 fft
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>f = fft(s)</TT>
</LI>
</UL>
<B>Output arguments:</B>

<UL>
<LI><TT>f</TT> - n by 2 array, the first column contains the magnitudes, the
second one the phases.
</LI>
</UL>
Fourier transform of scalar signal <TT>s</TT>.

<H3><A NAME="SECTION0072032300000000000000"></A>
<A NAME="f52"></A>
<BR>
6.20.3.23 filterbank
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>filterbank(s, depth, filterlen)</TT>
</LI>
</UL>
Filter scalar signal <TT>s</TT> into <!-- MATH
 $2^{\text{\tt depth}}$
 -->
<IMG
 WIDTH="43" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.gif"
 ALT="$ 2^{\text{\tt depth}}$">
 bands of equal bandwith,
using maximally flat filters.

<H3><A NAME="SECTION0072032400000000000000"></A>
<A NAME="f53"></A>
<BR>
6.20.3.24 firstmax
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>[xpos, unit] = firstmax(s)</TT>
</LI>
</UL>
Give information about first local maximum of scalar signal <TT>s</TT>.

<H3><A NAME="SECTION0072032500000000000000"></A>
<A NAME="f54"></A>
<BR>
6.20.3.25 firstmin
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>[xpos, unit] = firstmin(s)</TT>
</LI>
</UL>
Give information about first local minimum of scalar signal <TT>s</TT>.

<H3><A NAME="SECTION0072032600000000000000"></A>
<A NAME="f55"></A>
<BR>
6.20.3.26 firstzero
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>[xpos, unit] = firstzero(s)</TT>
</LI>
</UL>
Give information about first zero of scalar signal <TT>s</TT>, using linear interpolation.

<H3><A NAME="SECTION0072032700000000000000"></A>
<A NAME="f56"></A>
<BR>
6.20.3.27 fracdims
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = fracdims(s, kmin, kmax, Nref, gstart, gend, past, steps)</TT>
</LI>
<LI><TT>rs = fracdims(s, kmin, kmax, Nref, gstart, gend, past)</TT>
</LI>
<LI><TT>rs = fracdims(s, kmin, kmax, Nref, gstart, gend)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>kmin</TT> - minimal number of neighbors for each reference point
</LI>
<LI><TT>kmax</TT> - maximal number of neighbors for each reference point
</LI>
<LI><TT>Nref</TT> - number of randomly chosen reference points (n == -1 means : use all points)
</LI>
<LI><TT>gstart</TT> - starting value for moments
</LI>
<LI><TT>gend</TT> - end value for moments
</LI>
<LI><TT>past</TT> - (optional) number of samples to exclude before and after each reference index, default is 0
</LI>
<LI><TT>steps</TT> - (optional) number of moments to calculate, default is 32
</LI>
</UL>
Compute fractal dimension spectrum <TT>D(q)</TT> using moments of
neighbor distances for time-delay reconstructed timeseries <TT>s</TT>.

<P>
Do the main job - computing nearest neighbors for reference points.

<H3><A NAME="SECTION0072032800000000000000"></A>
<A NAME="f57"></A>
<BR>
6.20.3.28 getaxis
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>a = getaxis(s, dim)</TT>
</LI>
</UL>
Get one of the currend <TT>xaxes</TT>.

<H3><A NAME="SECTION0072032900000000000000"></A>
<A NAME="f58"></A>
<BR>
6.20.3.29 gmi
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>gmi(s, D, eps, NNR, len, Nref)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>D</TT> - 
</LI>
<LI><TT>eps</TT> -
</LI>
<LI><TT>NNR</TT> -
</LI>
<LI><TT>len</TT> - 
</LI>
<LI><TT>Nref</TT> -
</LI>
</UL>
Generalized mutual information function for a scalar time series

<H3><A NAME="SECTION0072033000000000000000"></A>
<A NAME="f59"></A>
<BR>
6.20.3.30 histo
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>histo(s, partitions)</TT>
</LI>
</UL>
Histogram function using equidistantly spaced partitions.

<H3><A NAME="SECTION0072033100000000000000"></A>
<A NAME="f60"></A>
<BR>
6.20.3.31 infodim
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = infodim(s, bins)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>s</TT> - data points (row vectors)
</LI>
<LI><TT>bins</TT> - maximal number of partition per axis, default is 100
</LI>
</UL>
Compute the information dimension of a time-delay reconstructed
timeseries <TT>s</TT> for dimensions from 1 to <TT>D</TT>, where <TT>D</TT> is
the dimension of the input vectors. Using boxcounting approach.
Scale data to be within 0 and 1.
Give a sortiment of (integer) partitionsizes with almost exponential behaviour.

<H3><A NAME="SECTION0072033200000000000000"></A>
<A NAME="f61"></A>
<BR>
6.20.3.32 infodim2
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = infodim2(s, n, kmax, past)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>n</TT> - number of randomly chosen reference points (n == -1 means : use all points)
</LI>
<LI><TT>kmax</TT> - maximal number of neighbors for each reference point
</LI>
<LI><TT>past</TT> - number of samples to exclude before and after each reference index
</LI>
</UL>
Compute scaling of moments of the nearest neighbor distances for
time-delay reconstructed timeseries <TT>s</TT>. This can be used to
calculate information dimension <TT>D1</TT>.

<P>
Numerically compute first derivative of <!-- MATH
 $\log\gamma(k)$
 -->
<IMG
 WIDTH="58" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img32.gif"
 ALT="$ \log\gamma(k)$">
 after <IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img33.gif"
 ALT="$ k$">
.

<H3><A NAME="SECTION0072033300000000000000"></A>
<A NAME="f62"></A>
<BR>
6.20.3.33 int
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>int(s)</TT>
</LI>
</UL>
Numerical integration along dimension 1 signal <TT>s</TT> has to be sampled equidistantly.

<H3><A NAME="SECTION0072033400000000000000"></A>
<A NAME="f63"></A>
<BR>
6.20.3.34 intspikeint
</H3> 
<B>Syntax:</B>

<UL>
<LI><TT>rs = intspikeint(s)</TT>
</LI>
</UL>
Compute the interspike intervalls for a spiked scalar timeseries,
using transformation on ranked values.

<H3><A NAME="SECTION0072033500000000000000"></A>
<A NAME="f64"></A>
<BR>
6.20.3.35 intspikint
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = intspikeint(s)</TT>
</LI>
</UL>
Compute the interspike intervalls for a spiked scalar timeseries,
using transformation on ranked values.

<H3><A NAME="SECTION0072033600000000000000"></A>
<A NAME="f65"></A>
<BR>
6.20.3.36 largelyap
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = largelyap(s, n, stepsahead, past, nnr)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>n</TT> - number of randomly chosen reference points (-1 means: use all points)
</LI>
<LI><TT>stepsahead</TT> - maximal length of prediction in samples
</LI>
<LI><TT>past</TT> - exclude  
</LI>
<LI><TT>nnr</TT> - number of nearest neighbours  <EM>(optional)</EM>
</LI>
</UL>
<B>Output arguments:</B>

<UL>
<LI><TT>rs</TT> - 
</LI>
</UL>
Compute the largest lyapunov exponent of a time-delay reconstructed
timeseries <TT>s</TT>, using formula (1.5. of Nonlinear Time-Series
Analysis, Ulrich Parlitz 1998 [<A
 HREF="node90.html#Parlitz:1998">146</A>]).

<H3><A NAME="SECTION0072033700000000000000"></A>
<A NAME="f66"></A>
<BR>
6.20.3.37 level_adaption
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>level_adaption(s, timeconstants, dynamic_limit, threshold)</TT>
</LI>
</UL>
Each channel of signal s is independently divided by a scaling factor that
adapts to the current level of the samples in this channel. The adaption
process is simulated using a cascade of feedback loops (P&#252;schel 1998) which
consists of low pass filters with time constants given as second argument 
to this function. The number of time constants given determines the number 
of feedback loops that are used. 

<P>
Higher values for time constants will result in slower adaption speed.
Short time changes in the signal will be transmitted almost linearily.
In each feedback loop, a nonlinear compressing characteristic (see
Stefan M&#252;nkner 1993) limits the signal values to be within 
<TT>[-dynamic_limit dynamic_limit]</TT>. A low value for <TT>dynamic_limit</TT> will
introduce nonlinear distortions to the signal.

<P>
To prevent the feedback loops from adapting to a zero level (in case all input
values are zero), a tiny threshold is given as 4th argument. The scaling factors
will not shrink below this threshold.

<H3><A NAME="SECTION0072033800000000000000"></A>
<A NAME="f67"></A>
<BR>
6.20.3.38 localdensity
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = localdensity(s, n, past)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>n</TT> - number of nearest neighbour to compute
</LI>
<LI><TT>past</TT> - a nearest neighbour is only valid if it is as least
          <TT>past</TT> timesteps away from the reference point
           <TT>past</TT> = 1 means: use all points but <TT>ref_point</TT> itself 
</LI>
</UL>
Uses accelerated searching, distances are calculated with euclidian norm.

<H3><A NAME="SECTION0072033900000000000000"></A>
<A NAME="f68"></A>
<BR>
6.20.3.39 max
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>[maximum, yunit, xpos, xunit] = max(s)</TT>
</LI>
</UL>
Give information about maximum of scalar signal <TT>s</TT>.

<P>
<B>Example:</B>
<PRE>
disp('maximum of signal : ')
disp(['y = ' num2str(m) ' ' label(yunit(s))]);
disp(['x = ' num2str(xpos) ' ' label(a)]);
</PRE>
<H3><A NAME="SECTION0072034000000000000000"></A>
<A NAME="f69"></A>
<BR>
6.20.3.40 medianfilt
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = medianfilt(s, len)</TT>
</LI>
</UL>
Moving median filter of width <TT>len</TT> samples for a scalar time
series  (<TT>len</TT> should be odd).

<H3><A NAME="SECTION0072034100000000000000"></A>
<A NAME="f70"></A>
<BR>
6.20.3.41 merge
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>merge(signal1, signal2, dB)</TT>
</LI>
<LI><TT>merge(signal1, signal2)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>signal1, signal2</TT> - Signals
</LI>
<LI><TT>dB</TT> - energy ratio, (optional, default = 0)
</LI>
</UL>
Merges signal <TT>s1</TT> and <TT>s2</TT> into a new signal with energy
ration <TT>dB</TT> (in decibel) a positive value of <TT>dB</TT> increases
the amount of <TT>signal1</TT> in the resulting signal.

<H3><A NAME="SECTION0072034200000000000000"></A>
<A NAME="f71"></A>
<BR>
6.20.3.42 min
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>[minimum, yunit, xpos, xunit] = min(s)</TT>
</LI>
</UL>
Give information about minimum of scalar signal <TT>s</TT>.

<P>
<B>Example:</B>
<PRE>
disp('minimum of signal : ')
disp(['y = ' num2str(m) ' ' label(yunit(s))]);
disp(['x = ' num2str(xpos) ' ' label(a)]);
</PRE>
<H3><A NAME="SECTION0072034300000000000000"></A>
<A NAME="f72"></A>
<BR>
6.20.3.43 minus
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs=minus(s, offset)</TT>
</LI>
<LI><TT>rs=minus(s1,s2)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>s, s1, s2</TT> - signal object
</LI>
<LI><TT>offset</TT> - scalar value
</LI>
</UL>
Calculate difference of signals <TT>s1</TT> and <TT>s2</TT> or substract a
scalar value from <TT>s</TT>.

<H3><A NAME="SECTION0072034400000000000000"></A>
<A NAME="f73"></A>
<BR>
6.20.3.44 movav
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = movav(s, len, windowtype)</TT>
</LI>
<LI><TT>rs = movav(s, len)</TT>
</LI>
</UL>
Moving average of width <TT>len</TT> (samples) along first dimension.

<H3><A NAME="SECTION0072034500000000000000"></A>
<A NAME="f74"></A>
<BR>
6.20.3.45 multires
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = multires(s)     =&gt; scale=3</TT>
</LI>
<LI><TT>rs = multires(s, scale)</TT>
</LI>
</UL>
Multires perform multiresolution analysis.
<TT>Y = MULTIRES (X,H,RH,G,RG,SC)</TT> obtains the SC successive details and
the low frequency approximation of signal in <TT>X</TT> from a multiresolution
scheme. The analysis lowpass filter <TT>H</TT>, synthesis lowpass filter
<TT>RH</TT>, analysis highpass filter <TT>G</TT> and synthesis
highpass filter <TT>RG</TT> are used to implement the scheme.

<P>
Results are given in a <TT>scale+1</TT> channels. The first scale
channels are the details corresponding to the scales 
<IMG
 WIDTH="19" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img34.gif"
 ALT="$ 2^1$">
 to <!-- MATH
 $2^{\text{\tt scale}}$
 -->
<IMG
 WIDTH="43" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img35.gif"
 ALT="$ 2^{\text{\tt scale}}$">
 the last row contains the
approximation at scale <!-- MATH
 $2^{\text{\tt SC}}$
 -->
<IMG
 WIDTH="25" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img36.gif"
 ALT="$ 2^{\text{\tt SC}}$">
. The original signal can be
restored by summing all the channels of the resulting signal.

<H3><A NAME="SECTION0072034600000000000000"></A>
<A NAME="f75"></A>
<BR>
6.20.3.46 nearneigh
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = nearneigh(s, n)    =&gt; past=1</TT>
</LI>
<LI><TT>rs = nearneigh(s, n, past)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>n</TT> - number of nearest neighbour to compute
</LI>
<LI><TT>past</TT> - a nearest neighbour is only valid if it is as least 
          past timesteps away from the reference point.
          past = 1 means: use all points but <TT>ref_point</TT> itself
</LI>
</UL>
<TT>n</TT> nearest neighbour algorithm. Find <TT>n</TT> nearest neighbours
(in order of increasing distances) to each point in signal <TT>s</TT>
uses accelerated searching, distances are calculated with euclidian norm.

<H3><A NAME="SECTION0072034700000000000000"></A>
<A NAME="f76"></A>
<BR>
6.20.3.47 norm1
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs=norm1(s)      =&gt; low=0 , upp=1</TT>
</LI>
<LI><TT>rs=norm1(s, low) =&gt; upp=1</TT>    
</LI>
<LI><TT>rs=norm1(s, low, upp)</TT>
</LI>
</UL>
Scale and move signal values to be within <TT>[low,upp]</TT>.

<H3><A NAME="SECTION0072034800000000000000"></A>
<A NAME="f77"></A>
<BR>
6.20.3.48 norm2
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs=norm2(s)</TT>
</LI>
</UL>
Normalize signal by removing it's mean and dividing by the standard deviation.

<H3><A NAME="SECTION0072034900000000000000"></A>
<A NAME="f78"></A>
<BR>
6.20.3.49 pca
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>[rs, eigvals, eigvecs] = pca(s)       =&gt; mode='normalized' , maxpercent = 95</TT>
</LI>
<LI><TT>[rs, eigvals, eigvecs] = pca(s, mode)                     =&gt; maxpercent = 95</TT>   
</LI>
<LI><TT>[rs, eigvals, eigvecs] = pca(s, mode, maxpercent)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI>each row of data is one 'observation', e.g. the sample values of
     all channels in a multichannel measurement at one point in time
</LI>
<LI><TT>mode</TT> can be one of the following : <TT>'normalized'</TT> (default), <TT>'mean', 'raw'</TT>

<UL>
<LI>in mode <TT>'normalized'</TT> each column of data is centered by removing its mean
       and then normalized by dividing through its standard deviation before
       the covariance matrix is calculated
</LI>
<LI>in mode <TT>'mean'</TT> only the mean of every column of data is removed
</LI>
<LI>in mode <TT>'raw'</TT> no preprocessing is applied to data
</LI>
</UL>
</LI>
<LI><TT>maxpercent</TT> gives the limit of the accumulated percentage of the resulting
     eigenvalues, default is 95 %
</LI>
</UL>
Principal component analysis of column orientated data set.

<H3><A NAME="SECTION0072035000000000000000"></A>
<A NAME="f79"></A>
<BR>
6.20.3.50 plosivity
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = plosivity(s, blen)        =&gt; flen=1 , thresh=0, windowtype = 'Rect'</TT>
</LI>
<LI><TT>rs = plosivity(s, blen, flen)           =&gt; thresh=0, windowtype = 'Rect'</TT>
</LI>
<LI><TT>rs = plosivity(s, blen, flen, thresh)             =&gt; windowtype = 'Rect'</TT>
</LI>
<LI><TT>rs = plosivity(s, blen, flen, thresh, windowtype)</TT>
</LI>
</UL>
Compute plosivity of a spectrogram. See also: <TT>window</TT> for list of possible window types.

<H3><A NAME="SECTION0072035100000000000000"></A>
<A NAME="f80"></A>
<BR>
6.20.3.51 plus
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs=plus(s, offset)</TT>
</LI>
<LI><TT>rs=plus(s1, s2)</TT>
</LI>
</UL>
Add two signals <TT>s1</TT> and <TT>s2</TT> or add a scalar value <TT>offset</TT> to <TT>s</TT>.

<H3><A NAME="SECTION0072035200000000000000"></A>
<A NAME="f81"></A>
<BR>
6.20.3.52 poincare
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs=poincare(s, ref)</TT>
</LI>
</UL>
Compute Poincare-section of an embedded time series the result is a
set of vector points with dimension <TT>DIM-1</TT>, when the input data
set of vectors had dimension <TT>DIM</TT>. The projection is done
orthogonal to the tangential vector at the vector with index.

<H3><A NAME="SECTION0072035300000000000000"></A>
<A NAME="f82"></A>
<BR>
6.20.3.53 power
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>power(s)</TT>
</LI>
</UL>
Calculate squared magnitude of each sample.

<H3><A NAME="SECTION0072035400000000000000"></A>
<A NAME="f83"></A>
<BR>
6.20.3.54 predict
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = predict(s, dim, delay, len)            =&gt; nnr=1</TT>
</LI>
<LI><TT>rs = predict(s, dim, delay, len, nnr)       =&gt; mode=0</TT>
</LI>
<LI><TT>rs = predict(s, dim, delay, len, nnr, mode)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>dim</TT> - dimension for time-delay reconstruction
</LI>
<LI><TT>delay</TT> - delay time (in samples) for time-delay reconstruction
</LI>
<LI><TT>len</TT> - length of prediction (number of output values) 
</LI>
<LI><TT>nnr</TT> - number of nearest neighbors to use (default is one)
</LI>
<LI><TT>step</TT> - stepsize (in samples) (default is one)
</LI>
<LI><TT>mode</TT>:

<UL>
<LI>0 = Output vectors are the mean of the images of the nearest neighbors
</LI>
<LI>1 = Output vectors are the distance weighted mean of the images of the nearest neighbors
</LI>
<LI>2 = Output vectors are calculated based on the local flow using the mean of the images of the neighbors
</LI>
<LI>3 = Output vectors are calculated based on the local flow using the weighted mean of the images of the neighbors
</LI>
</UL>
</LI>
</UL>
Local constant iterative prediction for scalar data, using fast nearest neighbor search.
Four methods of computing the prediction output are possible.

<H3><A NAME="SECTION0072035500000000000000"></A>
<A NAME="f84"></A>
<BR>
6.20.3.55 predict2
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = predict2(s, len, nnr, step, mode)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>len</TT> - length of prediction (number of output values) 
</LI>
<LI><TT>nnr</TT> - number of nearest neighbors to use (default is one)
</LI>
<LI><TT>step</TT> - stepsize (in samples) (default is one)
</LI>
<LI><TT>mode</TT>:

<UL>
<LI>0 = Output vectors are the mean of the images of the nearest neighbors
</LI>
<LI>1 = Output vectors are the distance weighted mean of the images of the nearest neighbors
</LI>
<LI>2 = Output vectors are calculated based on the local flow using the mean of the images of the neighbors
</LI>
<LI>3 = Output vectors are calculated based on the local flow using
        the weighted mean of the images of the neighbors 
</LI>
</UL>
</LI>
</UL>
Local constant iterative prediction for phase space data (e.g. 
data stemming from a time delay reconstruction of a 
scalar time series), using fast nearest neighbor search.
Four methods of computing the prediction output are possible.

<H3><A NAME="SECTION0072035600000000000000"></A>
<A NAME="f85"></A>
<BR>
6.20.3.56 rang
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = rang(s)</TT>
</LI>
</UL>
Transform scalar time series to rang values.

<H3><A NAME="SECTION0072035700000000000000"></A>
<A NAME="f86"></A>
<BR>
6.20.3.57 removeaxis
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>s = removeaxis(s, dim)</TT>
</LI>
</UL>
Remove axis one of the current <TT>xaxes</TT>. No bound checking for <TT>dim</TT>.

<H3><A NAME="SECTION0072035800000000000000"></A>
<A NAME="f87"></A>
<BR>
6.20.3.58 return_time
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = return_time(s, nnr, maxT)        =&gt; past=1</TT>
</LI>
<LI><TT>rs = return_time(s, nnr, maxT, past)</TT>
</LI>
<LI><TT>rs = return_time(s, nnr, maxT, past, N)</TT>
</LI>
</UL>
<B>Input arguments:</B>

<UL>
<LI><TT>nnr</TT> - number of nearest neighbors
</LI>
<LI><TT>maxT</TT> - maximal return time to consider
</LI>
<LI><TT>past</TT> - a nearest neighbor is only valid if it is as least past timesteps away from the reference point
            past = 1 means: use all points but tt ref_point itself
</LI>
<LI><TT>N</TT> - number of reference indices
</LI>
</UL>
Compute histogram of return times.

<H3><A NAME="SECTION0072035900000000000000"></A>
<A NAME="f88"></A>
<BR>
6.20.3.59 reverse
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs=reverse(s)</TT>
</LI>
</UL>
Reverse signal along dimension 1.

<H3><A NAME="SECTION0072036000000000000000"></A>
<A NAME="f89"></A>
<BR>
6.20.3.60 rms
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = rms(s)</TT>
</LI>
</UL>
Calculate root mean square value for signal along dimension 1.

<H3><A NAME="SECTION0072036100000000000000"></A>
<A NAME="f90"></A>
<BR>
6.20.3.61 scale
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>scale(signal, factor)</TT>
</LI>
</UL>
Scale signal by factor <TT>f</TT>.

<H3><A NAME="SECTION0072036200000000000000"></A>
<A NAME="f91"></A>
<BR>
6.20.3.62 scalogram
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = scalogram(s)                                    =&gt; scalemin=0.1</TT>
</LI>
<LI><TT>rs = scalogram(s, scalemin)                          =&gt; scalemax=1</TT>
</LI>
<LI><TT>rs = scalogram(s, scalemin, scalemax)                =&gt; scalestep=0.1</TT>
</LI>
<LI><TT>rs = scalogram(s, scalemin, scalemax, scalestep)     =&gt;   mlen=10</TT>
</LI>
<LI><TT>rs = scalogram(s, scalemin, scalemax, scalestep, mlen)</TT>
</LI>
</UL>
Scalogram of signal <TT>s</TT> using morlet wavelet. See also: <TT>spec2</TT>.

<H3><A NAME="SECTION0072036300000000000000"></A>
<A NAME="f92"></A>
<BR>
6.20.3.63 setaxis
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>s = setaxis(s, dim, achse)</TT>
</LI>
</UL>
Change one of the current xaxes.

<H3><A NAME="SECTION0072036400000000000000"></A>
<A NAME="f93"></A>
<BR>
6.20.3.64 setunit
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>s = setunir(s, dim, u)</TT>
</LI>
</UL>
Change unit of one of the current <TT>xaxes</TT>.

<H3><A NAME="SECTION0072036500000000000000"></A>
<A NAME="f94"></A>
<BR>
6.20.3.65 shift
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>s = shift(s, distance)</TT> (dim=1)
</LI>
<LI><TT>s = shift(s, distance, dim)</TT>
</LI>
</UL>
shift signal on axis No. dim by distance (measured in the unit of the axis) to the right

<H3><A NAME="SECTION0072036600000000000000"></A>
<A NAME="f95"></A>
<BR>
6.20.3.66 signal
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>s = signal(array)</TT>

<P>
creates a new signal object from a data array <TT>array</TT> 
the data inside the object can be retrieved with <TT>x = data(s)</TT>;

<P>
</LI>
<LI><TT>s = signal(array, achse1, achse2, ...)</TT>

<P>
creates a new signal object from a data array <TT>array</TT>, using <TT>achse1</TT> etc. as xachse entries

<P>
</LI>
<LI><TT>s = signal(array, unit1, unit2, ...)</TT>

<P>
creates a new signal object from a data array 'array', using unit1 etc. to create xachse objects 
</LI>
<LI><TT>s = signal(array, samplerate1, samplerate2, ...)</TT>

<P>
creates a new signal object from a data array <TT>array</TT>, using as xunit
's' (second) and scalar <TT>samplerate1</TT> as samplerate(s)
</LI>
</UL>

<P>
A signal object contains signal data, that is a collection of real or complex valued samples.
A signal can be one or multi-dimensional. The number of dimensions is the number of axes that
are needed to describe the the data. 

<P>
An example for an one-dimensional signal is a one-channel
measurement (timeseries), or the power spectrum of a one-channel measurement.
An example for a two-dimensional signal is a twelve-channel measurement, with one
time axis and a 'channel' axis. Another example for a two-dimensional signal is
a short time spectrogramm of a time series, where we have a time axis and a frequency axis.

<P>
Each axis can have a physical unit(e.g. 's' or 'Hz'), a starting point and a step value.
E.g. if a time-series is sampled with 1000 Hz, beginning at 1 min 12 sec, the unit is 's',
the starting point is 72 and the step value (delta) is 0.001.

<P>
But not only the axes have physical units, also the sample value themselve can have a
unit, maybe 'V' or 'Pa', depending on what the sampled data represent (=&gt; yunit)

<P>
All units are stored as objects of class 'unit', all axes are stored as objects
of class 'achse' (this somewhat peculiar name was chosen because of conflicts with
reserved matlab keywords 'axis' and 'axes', which otherwise would have been the first choice).

<P>
Example for creating a 2-dimensional signal with y-unit set to 'Volt', the first dimension's unit is
'second' (time), the second dimension's unit is 'n' (Channels).

<P>
<B>Examples:</B>

<UL>
<LI><PRE> 
 tmp = rand(100, 10);
 
 s = signal(tmp, unit('s'), unit('n'));
 s = setyunit(s, unit('V'));
 s = addcomment(s, 'Example signal with two dimensions')
</PRE>

<P>
</LI>
<LI>Loading from disk
<PRE> s = signal(filename)
</PRE>
 loads a previously stored signal object

<P>
</LI>
<LI>Importing from other file formats:
<PRE> 
 ASCII: s = signal('data/spalte1.dat', 'ASCII')
 WAVE: s = signal('data/Sounds/hat.wav', 'WAVE')
 AU (SUN AUDIO): s = signal('data/Sounds/hat.au', 'AU')
 (old) NLD-Format : s = signal('test.nld', 'NLD')
</PRE>
</LI>
</UL>
<H3><A NAME="SECTION0072036700000000000000"></A>
<A NAME="f96"></A>
<BR>
6.20.3.67 spacing
</H3>

<UL>
<LI><TT>v = spacing(s)</TT>   (dim=1)
</LI>
<LI><TT>v = spacing(s, dim)</TT>
</LI>
</UL>
return spacing values for xaxis nr. dim

<H3><A NAME="SECTION0072036800000000000000"></A>
<A NAME="f97"></A>
<BR>
6.20.3.68 spec
</H3>
<B>Syntax:</B>

<UL>
<LI>rs = spec(s)
</LI>
</UL>
compute power spectrum for real valued scalar signals. Multivariate signals are
accepted but may produce unwanted results as only the spectrum of the first
column is returned.

<H3><A NAME="SECTION0072036900000000000000"></A>
<A NAME="f98"></A>
<BR>
6.20.3.69 spec2
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = spec2(s)</TT>
</LI>
</UL>
<B>Input Arguments:</B>

<UL>
<LI><TT>fensterlen</TT> - size of window  <EM>(optional)</EM>
</LI>
<LI><TT>fenster</TT> - window type  <EM>(optional)</EM>
</LI>
<LI><TT>vorschub</TT> - shift in samples  <EM>(optional)</EM>
</LI>
</UL>
spectrogramm of signal s using short time fft

<P>
<B>Examples:</B>
<PRE>
view(spec2(sine(10000, 1000, 8000), 512, 'Hanning'))
</PRE>
<H3><A NAME="SECTION0072037000000000000000"></A>
<A NAME="f99"></A>
<BR>
6.20.3.70 stts
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = stts(s, I)</TT>         (J=0, K=1, L=1)
</LI>
<LI><TT>rs = stts(s, I, J)</TT>      (K=1, L=1)
</LI>
<LI><TT>rs = stts(s, I, J, K)</TT>   (L=1)
</LI>
<LI><TT>rs = stts(s, I, J, K, L)</TT>
</LI>
</UL>
<B>Input Arguments:</B>

<UL>
<LI><TT>s</TT> - input data set of N snapshots of length M, given as N by M matrix
</LI>
<LI><TT>I</TT> - number of spatial neighbours
</LI>
<LI><TT>J</TT> - number of temporal neighbours (in the past)
</LI>
<LI><TT>K</TT> - spatial shift (= spatial delay)
</LI>
<LI><TT>L</TT> - temporal delay
</LI>
</UL>
Spatiotemporal prediction conforming to U. Parlitz, NONLINEAR
TIME-SERIES ANALYSIS Chapter 1.10.2.1.

<P>

<H3><A NAME="SECTION0072037100000000000000"></A>
<A NAME="f100"></A>
<BR>
6.20.3.71 sttserror
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = sttserror(s1, s2)</TT>
</LI>
</UL>
<B>Input Arguments:</B>

<UL>
<LI><TT>s1</TT> - original signal
</LI>
<LI><TT>s2</TT> - predicted signal
</LI>
</UL>
 compute error function for prediction of spatial-temporal systems
<BR>
see U. Parlitz <TT>"</TT>Nonlinear Time Series Analysis<TT>"</TT>, Section 1.10.2.2 Eq. 1.10

<H3><A NAME="SECTION0072037200000000000000"></A>
<A NAME="f101"></A>
<BR>
6.20.3.72 surrogate1
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = surrogate1(s)</TT>
</LI>
</UL>
create surrogate data for a scalar time series by randomizing phases of fourier spectrum
<BR>
see : James Theiler et al.'Using Surrogate Data to Detect Nonlinearity in Time Series', APPENDIX : ALGORITHM I

<H3><A NAME="SECTION0072037300000000000000"></A>
<A NAME="f102"></A>
<BR>
6.20.3.73 surrogate2
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = surrogate2(s)</TT>
</LI>
</UL>
create surrogate data for a scalar time series
<BR>
see : James Theiler et al.'Using Surrogate Data to Detect Nonlinearity in Time Series', APPENDIX : ALGORITHM II

<H3><A NAME="SECTION0072037400000000000000"></A>
<A NAME="f103"></A>
<BR>
6.20.3.74 surrogate3
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = surrogate3(s)</TT>
</LI>
</UL>
create surrogate data for a scalar time series by permuting samples randomly

<H3><A NAME="SECTION0072037500000000000000"></A>
<A NAME="f104"></A>
<BR>
6.20.3.75 surrogate_test
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs=surrogate_test(s, ntests, method,func)</TT>
</LI>
</UL>
<B>Input Arguments:</B>

<UL>
<LI><TT>s</TT> - has to be a real, scalar signal
</LI>
<LI><TT>ntests</TT> - is the number of surrogate data sets to create
</LI>
<LI><TT>method</TT> - method to generate surrogate data sets:

<UL>
<LI>1: surrogate1
</LI>
<LI>2: surrogate2
</LI>
<LI>3: surrogate3
</LI>
</UL>
</LI>
<LI><TT>func</TT> - string with matlab-code, have to return a signal
 object with a scalar time series. The data to process is a signal
 object referred by the qualifier <TT>s</TT> (see example).
</LI>
</UL>
<B>Output Arguments:</B>

<UL>
<LI><TT>rs</TT> is a signal object with a three dimensional time
 series. The first component is the result of the <TT>func</TT> function
 applied to the original data set <TT>s</TT>. The second component is the 
 mean of the result of the <TT>func</TT> function applied to the <TT>   ntests</TT> surrogate data sets. The third component is the standard
 deviation. There is a special <TT>plothint</TT> ('surrerrorbar') for the <TT>view</TT> function to 
 show this result in the common way.
</LI>
</UL>
<TT>surrogate_test</TT> runs an automatic surrogate data test task. It
generates <TT>ntests</TT> surrogate data sets an performs the <TT>func</TT>
function to each set. <TT>func</TT> is a string with matlab-code who
returns a signal <TT>s</TT> with a scalar time series.

<P>
<B>Example:</B>
<PRE>
st = surrogate_test(s, 10, 1, 1, 'largelyap(embed(s,3,1,1), 128,20,10);');
</PRE>
<H3><A NAME="SECTION0072037600000000000000"></A>
<A NAME="f105"></A>
<BR>
6.20.3.76 swap
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = swap(s)</TT>  (exchange dimension 1 and dimension 2)
</LI>
<LI><TT>rs = swap(s, dim1, dim2)</TT>
</LI>
</UL>
Exchange signal's dimensions (and axes)

<H3><A NAME="SECTION0072037700000000000000"></A>
<A NAME="f106"></A>
<BR>
6.20.3.77 takens_estimator
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>D2 = takens_estimator2(s, n, range, past)</TT>
</LI>
</UL>
<B>Input Arguments:</B>

<UL>
<LI><TT>n</TT> - number of randomly chosen reference points (n == -1 means : use all points)
</LI>
<LI><TT>range</TT> - maximal relative search radius (relative to attractor size) 0..1
</LI>
<LI><TT>past</TT> - number of samples to exclude before and after each reference index
</LI>
</UL>
Takens estimator for correlation dimension

<H3><A NAME="SECTION0072037800000000000000"></A>
<A NAME="tc3"></A>
<BR>
6.20.3.78 tc3
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = tc3(s,tau,n,method)</TT>
</LI>
</UL>
<B>Input Arguments:</B>

<UL>
<LI><TT>tau</TT> - see explaination below
</LI>
<LI><TT>n</TT> - number of surrogate data sets to generate
</LI>
<LI><TT>method</TT> - method to generate the surrogate data sets:

<UL>
<LI>1: <TT>surrogate1</TT>
</LI>
<LI>2: <TT>surrogate2</TT>
</LI>
<LI>3: <TT>surrogate3</TT>
</LI>
</UL>
</LI>
</UL>
<B>Output Arguments:</B>

<UL>
<LI><TT>rs</TT> is a row vector, returned as signal object. The first
 item is the <IMG
 WIDTH="31" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img37.gif"
 ALT="$ T_{C3}$">
 value for the original data set <TT>s</TT>. The
 following <TT>n</TT> values are the <IMG
 WIDTH="31" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img37.gif"
 ALT="$ T_{C3}$">
 values for the generated
 surrogates. There exist a special <TT>plothint</TT> ('surrbar') for the
 <TT>view</TT> function to show this kind of result in the common way.
</LI>
</UL>

<P>
This function calculates a special value for the original data set and 
the <TT>n</TT> generated surrogate data sets. The <IMG
 WIDTH="31" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img37.gif"
 ALT="$ T_{C3}$">
 value is
defined as followed:
<P><!-- MATH
 \begin{displaymath}
T_{C3}(\{x_n\},\tau)=\frac{\langle
  x_nx_{n-\tau}x_{n-2\tau}\rangle}{|\langle x_nx_{n-\tau}\rangle|^{\frac
    3 2}}
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="224" HEIGHT="55" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.gif"
 ALT="$\displaystyle T_{C3}(\{x_n\},\tau)=\frac{\langle
x_nx_{n-\tau}x_{n-2\tau}\rangle}{\vert\langle x_nx_{n-\tau}\rangle\vert^{\frac
3 2}}
$">
</DIV><P>
</P>
In terms of surrogate data test this is a test statistics for higher
order moments. The original <TT>tc3</TT> function is located under
<TT>utils/tc3.m</TT> and use simple matlab
vectors.

<P>

<H3><A NAME="SECTION0072037900000000000000"></A>
<A NAME="f107"></A>
<BR>
6.20.3.79 trend
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = trend(s, len)</TT>
</LI>
</UL>
trend correction
<BR>
calculate moving average of width <TT>len</TT> (samples) for a scalar time series
(<TT>len</TT> should be odd) and remove the result from the input signal

<H3><A NAME="SECTION0072038000000000000000"></A>
<A NAME="trev"></A>
<BR>
6.20.3.80 trev
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = trev(s,tau,n,method)</TT>
</LI>
</UL>
<B>Input Arguments:</B>

<UL>
<LI><TT>tau</TT> - see explaination below
</LI>
<LI><TT>n</TT> - number of surrogate data sets to generate
</LI>
<LI><TT>method</TT> - method to generate the surrogate data sets:

<UL>
<LI>1: <TT>surrogate1</TT>
</LI>
<LI>2: <TT>surrogate2</TT>
</LI>
<LI>3: <TT>surrogate3</TT>
</LI>
</UL>
</LI>
</UL>
<B>Output Arguments:</B>

<UL>
<LI><TT>rs</TT> is a row vector, returned as signal object. The first
 item is the <IMG
 WIDTH="44" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.gif"
 ALT="$ T_{REV}$">
 value for the original data set <TT>s</TT>. The
 following <TT>n</TT> values are the <IMG
 WIDTH="44" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.gif"
 ALT="$ T_{REV}$">
 values for the generated
 surrogates. There exist a special <TT>plothint</TT> ('surrbar') for the
 <TT>view</TT> function to show this kind of result in the common way.
</LI>
</UL>

<P>
This function calculates a special value for the original data set and 
the <TT>n</TT> generated surrogate data sets. The <IMG
 WIDTH="44" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.gif"
 ALT="$ T_{REV}$">
 value is
defined as followed:
<P><!-- MATH
 \begin{displaymath}
T_{REV}(\{x_n\},\tau)=\frac{\langle
  (x_n-x_{n-\tau})^3\rangle}{\langle(x_n-x_{n-\tau})^2\rangle^{\frac 3
    2}}
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="245" HEIGHT="57" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.gif"
 ALT="$\displaystyle T_{REV}(\{x_n\},\tau)=\frac{\langle
(x_n-x_{n-\tau})^3\rangle}{\langle(x_n-x_{n-\tau})^2\rangle^{\frac 3
2}}
$">
</DIV><P>
</P>
In terms of surrogate data test this is a test statistics for 
time reversibility. The original <TT>trev</TT> function is located under
<TT>utils/trev.m</TT> and use simple matlab
vectors.

<H3><A NAME="SECTION0072038100000000000000"></A>
<A NAME="f108"></A>
<BR>
6.20.3.81 upsample
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>rs = upsample(s, factor, method)</TT>
</LI>
</UL>
<B>Input Arguments:</B>

<UL>
<LI><TT>method</TT> may be one of the following :

<UL>
<LI><TT>'fft'</TT>
</LI>
<LI><TT>'spline'</TT>
</LI>
<LI><TT>'akima'</TT>
</LI>
<LI><TT>'nearest'</TT>
</LI>
<LI><TT>'linear'</TT>
</LI>
<LI><TT>'cubic'</TT>
</LI>
</UL>
</LI>
<LI><TT>s</TT> has be to sampled equidistantly for fft interpolation
</LI>
</UL>
Change sample rate of signal s by one-dimensional interpolation

<H3><A NAME="SECTION0072038200000000000000"></A>
<A NAME="f109"></A>
<BR>
6.20.3.82 view
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>view(signal)</TT>              (fontsize=12)
</LI>
<LI><TT>view(signal, fontsize)</TT>
</LI>
<LI><TT>view(signal, fontsize, figurehandle)</TT>
</LI>
</UL>
Signal viewer that decides from the signal's attributes which kind of plot to
produce, using the signal's plothint entry to get a hint which kind of plot to produce
<BR>
Possible plothints are:

<UL>
<LI><TT>'graph'</TT>
</LI>
<LI><TT>'bar'</TT>
</LI>
<LI><TT>'surrbar'</TT>
</LI>
<LI><TT>'surrerrorbar'</TT>
</LI>
<LI><TT>'points'</TT>
</LI>
<LI><TT>'xyplot'</TT>
</LI>
<LI><TT>'xypoints'</TT>
</LI>
<LI><TT>'scatter'</TT>
</LI>
<LI><TT>'3dcurve'</TT>
</LI>
<LI><TT>'3dpoints'</TT>
</LI>
<LI><TT>'spectrogram'</TT>
</LI>
<LI><TT>'image'</TT>
</LI>
<LI><TT>'multigraph'</TT>
</LI>
<LI><TT>'multipoints'</TT>
</LI>
<LI><TT>'subplotgraph'</TT>
</LI>
</UL>
<H3><A NAME="SECTION0072038300000000000000"></A>
<A NAME="f110"></A>
<BR>
6.20.3.83 write
</H3>
<B>Syntax:</B>

<UL>
<LI><TT>write(s, filename)</TT>            (writes in TSTOOL's own file format)
</LI>
<LI><TT>write(s, filename, 'ASCII')</TT>
</LI>
<LI><TT>write(s, filename, 'WAV')</TT>     (RIFF WAVE FORMAT)
</LI>
<LI><TT>write(s, filename, 'AU')</TT>      (SUN AUDIO FORMAT)
</LI>
<LI><TT>write(s, filename, 'NLD')</TT>     (old NLD FORMAT)
</LI>
<LI><TT>write(s, filename, 'SIPP')</TT>    (si++ file format)
</LI>
</UL>
writes a signal object to file filename (uses matlab's file format)

<HR>
<!--Navigation Panel-->
<A NAME="tex2html1256"
  HREF="node61.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.gif"></A> 
<A NAME="tex2html1252"
  HREF="node57.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.gif"></A> 
<A NAME="tex2html1248"
  HREF="node59.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.gif"></A> 
<A NAME="tex2html1254"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1257"
  HREF="node61.html">6.21 Class description</A>
<B> Up:</B> <A NAME="tex2html1253"
  HREF="node57.html">6.20 Class signal</A>
<B> Previous:</B> <A NAME="tex2html1249"
  HREF="node59.html">6.20.2 Attributes</A>
 &nbsp; <B>  <A NAME="tex2html1255"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<IMG SRC=logo.jpg  ALT=TSTOOL BORDER=0>
<BR>
<BR><FONT SIZE=2>Copyright &#169; 1997-2009 <A HREF=http://www.physik3.gwdg.de>DPI G&ouml;ttingen</A></TABLE>
</BODY></HTML>

</ADDRESS>
</BODY>
</HTML>
